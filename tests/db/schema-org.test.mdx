---
$type: TestSuite
$id: https://mdx.org.ai/tests/schema-org
title: Schema.org Ingestion Tests
description: Ingest schema.org types from JSON-LD, transform, and generate embeddings
---

# Schema.org Ingestion Tests

Test ingesting schema.org types and properties, transforming from JSON-LD,
and generating embeddings for semantic search.

## Schema Definition

```ts
const schema = {
  SchemaType: {
    label: 'string',
    comment: 'string',
    subClassOf: 'string?',
    properties: 'json',
    embedding: 'json?',
  },
  SchemaProperty: {
    label: 'string',
    comment: 'string',
    domainIncludes: ['SchemaType.properties'],
    rangeIncludes: 'string',
    embedding: 'json?',
  },
}

const db = DB(schema)
```

## Ingest Core Types

```ts test name="ingest Thing type"
import { DB } from 'ai-database'

const db = DB({
  SchemaType: {
    label: 'string',
    comment: 'string',
    subClassOf: 'string?',
  },
})

// Root type - use unique ID per test
const id = `Thing_${Date.now()}`
await db.SchemaType.create(id, {
  label: 'Thing',
  comment: 'The most generic type of item.',
  subClassOf: null,
})

const thing = await db.SchemaType.get(id)
expect(thing.label).toBe('Thing')
expect(thing.subClassOf).toBeNull()
```

```ts test name="ingest type hierarchy"
import { DB } from 'ai-database'

const db = DB({
  SchemaType: {
    label: 'string',
    comment: 'string',
    subClassOf: 'string?',
  },
})

const suffix = Date.now()
// Build hierarchy: Thing -> CreativeWork -> Article -> BlogPosting
const types = [
  { id: `Thing_${suffix}`, label: 'Thing', comment: 'The most generic type.', subClassOf: null },
  { id: `CreativeWork_${suffix}`, label: 'CreativeWork', comment: 'A creative work.', subClassOf: `Thing_${suffix}` },
  { id: `Article_${suffix}`, label: 'Article', comment: 'An article.', subClassOf: `CreativeWork_${suffix}` },
  { id: `BlogPosting_${suffix}`, label: 'BlogPosting', comment: 'A blog post.', subClassOf: `Article_${suffix}` },
]

for (const type of types) {
  await db.SchemaType.create(type.id, {
    label: type.label,
    comment: type.comment,
    subClassOf: type.subClassOf,
  })
}

const blogPosting = await db.SchemaType.get(`BlogPosting_${suffix}`)
expect(blogPosting.subClassOf).toBe(`Article_${suffix}`)

const article = await db.SchemaType.get(`Article_${suffix}`)
expect(article.subClassOf).toBe(`CreativeWork_${suffix}`)
```

```ts test name="ingest common types"
import { DB } from 'ai-database'

const db = DB({
  SchemaType: {
    label: 'string',
    comment: 'string',
    subClassOf: 'string?',
  },
})

const suffix = `${Date.now()}_${Math.random().toString(36).slice(2)}`
const commonTypes = [
  'Thing', 'Action', 'CreativeWork', 'Event', 'Intangible',
  'Organization', 'Person', 'Place', 'Product',
]

for (const typeName of commonTypes) {
  await db.SchemaType.create(`${typeName}_${suffix}`, {
    label: typeName,
    comment: `The ${typeName} type from schema.org`,
    subClassOf: 'Thing',
  })
}

const person = await db.SchemaType.get(`Person_${suffix}`)
expect(person.label).toBe('Person')
```

## Transform from JSON-LD

```ts test name="transform JSON-LD to entity"
import { DB } from 'ai-database'

const db = DB({
  SchemaType: {
    label: 'string',
    comment: 'string',
    subClassOf: 'string?',
  },
})

// Simulated JSON-LD response from schema.org
const jsonld = {
  '@context': 'https://schema.org',
  '@type': 'rdfs:Class',
  '@id': 'schema:Person',
  'rdfs:label': 'Person',
  'rdfs:comment': 'A person (alive, dead, undead, or fictional).',
  'rdfs:subClassOf': { '@id': 'schema:Thing' },
}

// Transform
const entity = {
  label: jsonld['rdfs:label'],
  comment: jsonld['rdfs:comment'],
  subClassOf: jsonld['rdfs:subClassOf']?.['@id']?.replace('schema:', ''),
}

const id = `Person_jsonld_${Date.now()}`
await db.SchemaType.create(id, entity)

const person = await db.SchemaType.get(id)
expect(person.label).toBe('Person')
expect(person.subClassOf).toBe('Thing')
```

## Search Types

```ts test name="search schema types"
import { DB } from 'ai-database'

const db = DB({
  SchemaType: {
    label: 'string',
    comment: 'string',
  },
})

const suffix = Date.now()
await db.SchemaType.create(`Person_search_${suffix}`, {
  label: 'Person',
  comment: 'A person (alive, dead, undead, or fictional).',
})
await db.SchemaType.create(`Organization_search_${suffix}`, {
  label: 'Organization',
  comment: 'An organization such as a school, NGO, corporation, club, etc.',
})
await db.SchemaType.create(`Place_search_${suffix}`, {
  label: 'Place',
  comment: 'Entities that have a physical location.',
})

const personResults = await db.SchemaType.search('person')
expect(personResults.length).toBeGreaterThanOrEqual(1)
const personResult = personResults.find(r => r.label === 'Person')
expect(personResult).toBeDefined()
```

## Properties

```ts test name="ingest properties with domain/range"
import { DB } from 'ai-database'

const db = DB({
  SchemaType: { label: 'string' },
  SchemaProperty: {
    label: 'string',
    comment: 'string',
    domainIncludes: 'string',
    rangeIncludes: 'string',
  },
})

const suffix = Date.now()
await db.SchemaType.create(`Person_props_${suffix}`, { label: 'Person' })

await db.SchemaProperty.create(`name_${suffix}`, {
  label: 'name',
  comment: 'The name of the item.',
  domainIncludes: 'Thing',
  rangeIncludes: 'Text',
})

await db.SchemaProperty.create(`email_${suffix}`, {
  label: 'email',
  comment: 'Email address.',
  domainIncludes: 'Person',
  rangeIncludes: 'Text',
})

await db.SchemaProperty.create(`birthDate_${suffix}`, {
  label: 'birthDate',
  comment: 'Date of birth.',
  domainIncludes: 'Person',
  rangeIncludes: 'Date',
})

const allProps = await db.SchemaProperty.list()
const personProps = allProps.filter(p => p.domainIncludes === 'Person')
expect(personProps.length).toBe(2) // email and birthDate
```

## Full Matrix Test

Run across all providers to verify consistent behavior:

```bash
# Test on all Node providers
mdxe test --target node --db all --filter schema-org

# Test on Workers providers
mdxe test --target workers --db all --filter schema-org

# Full matrix
mdxe test --target all --db all --filter schema-org
```
