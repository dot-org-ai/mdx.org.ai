---
$type: TestSuite
$id: https://mdx.org.ai/tests/rpc
title: RPC.do Tests
description: Test rpc.do Proxy-based RPC client and transports
---

# RPC.do Tests

Test the `rpc.do` package:
- Proxy-based RPC client
- HTTP transport
- WebSocket transport
- Service binding transport
- Composite transport

## RPC Proxy Creation

```ts test name="create RPC proxy with http transport"
import { RPC, http } from 'rpc.do'

// Create a mock transport for testing
const mockTransport = {
  async call(method: string, args: any[]) {
    if (method === 'echo') return args[0]
    if (method === 'add') return args[0] + args[1]
    throw new Error(`Unknown method: ${method}`)
  }
}

const rpc = RPC(mockTransport)

const result = await rpc.echo('hello')
expect(result).toBe('hello')

const sum = await rpc.add(2, 3)
expect(sum).toBe(5)
```

```ts test name="nested method calls via proxy"
import { RPC } from 'rpc.do'

const mockTransport = {
  async call(method: string, args: any[]) {
    // method will be the full path like "ai.generate" or "db.users.get"
    if (method === 'ai.generate') {
      return { text: `Generated: ${args[0].prompt}` }
    }
    if (method === 'db.users.get') {
      return { id: args[0].id, name: 'Test User' }
    }
    throw new Error(`Unknown method: ${method}`)
  }
}

const rpc = RPC(mockTransport)

const generated = await rpc.ai.generate({ prompt: 'hello' })
expect(generated.text).toBe('Generated: hello')

const user = await rpc.db.users.get({ id: '123' })
expect(user.id).toBe('123')
expect(user.name).toBe('Test User')
```

```ts test name="RPC proxy with async transport factory"
import { RPC } from 'rpc.do'

// Transport can be provided as a factory function
const transportFactory = async () => ({
  async call(method: string, args: any[]) {
    return `called: ${method}`
  }
})

const rpc = RPC(transportFactory)

const result = await rpc.someMethod('arg1')
expect(result).toBe('called: someMethod')
```

## Transport Types

```ts test name="http transport interface"
import { http } from 'rpc.do'

// http() returns a Transport
const transport = http('https://api.example.com/rpc')

expect(typeof transport.call).toBe('function')
```

```ts test name="ws transport interface"
import { ws } from 'rpc.do'

// ws() returns a Transport
const transport = ws('wss://api.example.com/rpc')

expect(typeof transport.call).toBe('function')
```

```ts test name="composite transport fallback"
import { RPC, composite } from 'rpc.do'

let callCount = 0
const failingTransport = {
  async call() {
    callCount++
    throw new Error('Primary failed')
  }
}

const fallbackTransport = {
  async call(method: string, args: any[]) {
    callCount++
    return 'fallback result'
  }
}

const transport = composite(failingTransport, fallbackTransport)
const rpc = RPC(transport)

const result = await rpc.test()
expect(result).toBe('fallback result')
expect(callCount).toBe(2) // Tried both transports
```

## Type Safety

```ts test name="typed RPC proxy"
import { RPC, type RPCProxy, type RPCFunction } from 'rpc.do'

// Define API interface
interface API {
  greet: (input: { name: string }) => { message: string }
  math: {
    add: (input: { a: number; b: number }) => { result: number }
  }
}

const mockTransport = {
  async call(method: string, args: any[]) {
    if (method === 'greet') {
      return { message: `Hello, ${args[0].name}!` }
    }
    if (method === 'math.add') {
      return { result: args[0].a + args[0].b }
    }
  }
}

// Create typed RPC client
const rpc = RPC<API>(mockTransport)

const greeting = await rpc.greet({ name: 'World' })
expect(greeting.message).toBe('Hello, World!')

const sum = await rpc.math.add({ a: 10, b: 20 })
expect(sum.result).toBe(30)
```

## Error Handling

```ts test name="RPC error propagation"
import { RPC } from 'rpc.do'

const errorTransport = {
  async call(method: string) {
    throw new Error(`Method ${method} failed`)
  }
}

const rpc = RPC(errorTransport)

await expect(rpc.failingMethod()).rejects.toThrow('Method failingMethod failed')
```

```ts test name="RPC with validation errors"
import { RPC } from 'rpc.do'

const validatingTransport = {
  async call(method: string, args: any[]) {
    if (!args[0] || typeof args[0] !== 'object') {
      throw new Error('First argument must be an object')
    }
    return { success: true }
  }
}

const rpc = RPC(validatingTransport)

await expect(rpc.validate('not-an-object')).rejects.toThrow('First argument must be an object')

const result = await rpc.validate({ valid: true })
expect(result.success).toBe(true)
```

## Auth Provider

```ts test name="auth provider interface"
import { auth, type AuthProvider } from 'rpc.do'

// auth() returns an AuthProvider function
const getToken = auth()
expect(typeof getToken).toBe('function')

// It returns a token or null
const token = await getToken()
expect(token === null || typeof token === 'string').toBe(true)
```

## Run Matrix

```bash
# Run on Node
mdxe test --target node --filter rpc

# Run on Workers
mdxe test --target workers --filter rpc

# Both
mdxe test --target all --filter rpc
```
