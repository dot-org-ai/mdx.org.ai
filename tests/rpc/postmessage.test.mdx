---
$type: TestSuite
$id: https://mdx.org.ai/tests/rpc/postmessage
title: Custom Transport Tests
description: Tests for custom RPC transports using MessageChannel
---

# Custom Transport Tests

Tests for creating custom RPC transports using the `rpc.do` Transport interface.
Demonstrates how to build a postMessage/MessageChannel transport.

## Transport Interface

```ts test name="transport interface contract"
import type { Transport } from 'rpc.do'

// A Transport must have a call method
const validTransport: Transport = {
  async call(method: string, args: any[]) {
    return { method, args }
  }
}

expect(typeof validTransport.call).toBe('function')
```

```ts test name="transport with optional close"
import type { Transport } from 'rpc.do'

// Transport can optionally have a close method
const closableTransport: Transport = {
  async call(method: string, args: any[]) {
    return { method, args }
  },
  close() {
    // Cleanup resources
  }
}

expect(typeof closableTransport.close).toBe('function')
```

## MessageChannel Transport

```ts test name="create MessageChannel transport"
import { RPC, type Transport } from 'rpc.do'

// Create a Transport that uses MessageChannel
function createChannelTransport(): { client: Transport; server: MessagePort } {
  const channel = new MessageChannel()
  let messageId = 0
  const pending = new Map<number, { resolve: Function; reject: Function }>()

  // Client side
  const client: Transport = {
    call(method: string, args: any[]) {
      return new Promise((resolve, reject) => {
        const id = ++messageId
        pending.set(id, { resolve, reject })
        channel.port1.postMessage({ id, method, args })
      })
    },
    close() {
      channel.port1.close()
    }
  }

  // Handle responses
  channel.port1.onmessage = (e) => {
    const { id, result, error } = e.data
    const p = pending.get(id)
    if (p) {
      pending.delete(id)
      if (error) p.reject(new Error(error))
      else p.resolve(result)
    }
  }

  channel.port1.start()
  channel.port2.start()

  return { client, server: channel.port2 }
}

const { client, server } = createChannelTransport()

// Set up server handler
server.onmessage = (e) => {
  const { id, method, args } = e.data
  let result
  let error

  try {
    if (method === 'echo') result = args[0]
    else if (method === 'add') result = args[0] + args[1]
    else error = `Unknown method: ${method}`
  } catch (e: any) {
    error = e.message
  }

  server.postMessage({ id, result, error })
}

// Test the transport
const rpc = RPC(client)

const echo = await rpc.echo('channel test')
expect(echo).toBe('channel test')

const sum = await rpc.add(10, 20)
expect(sum).toBe(30)

client.close?.()
server.close()
```

```ts test name="concurrent MessageChannel requests"
import { RPC, type Transport } from 'rpc.do'

// Simplified channel transport
const channel = new MessageChannel()
let msgId = 0
const pending = new Map<number, { resolve: Function; reject: Function }>()

const transport: Transport = {
  call(method, args) {
    return new Promise((resolve, reject) => {
      const id = ++msgId
      pending.set(id, { resolve, reject })
      channel.port1.postMessage({ id, method, args })
    })
  },
  close: () => channel.port1.close()
}

channel.port1.onmessage = (e) => {
  const { id, result } = e.data
  pending.get(id)?.resolve(result)
  pending.delete(id)
}

channel.port2.onmessage = (e) => {
  const { id, method, args } = e.data
  // Echo the first arg multiplied by 2
  channel.port2.postMessage({ id, result: args[0] * 2 })
}

channel.port1.start()
channel.port2.start()

const rpc = RPC(transport)

// Fire concurrent requests
const promises = Array.from({ length: 5 }, (_, i) =>
  rpc.double(i + 1)
)

const results = await Promise.all(promises)
expect(results).toEqual([2, 4, 6, 8, 10])

transport.close?.()
channel.port2.close()
```

## Error Handling

```ts test name="MessageChannel error handling"
import { RPC, type Transport } from 'rpc.do'

const channel = new MessageChannel()
let msgId = 0
const pending = new Map<number, { resolve: Function; reject: Function }>()

const transport: Transport = {
  call(method, args) {
    return new Promise((resolve, reject) => {
      const id = ++msgId
      pending.set(id, { resolve, reject })
      channel.port1.postMessage({ id, method, args })
    })
  }
}

channel.port1.onmessage = (e) => {
  const { id, result, error } = e.data
  const p = pending.get(id)
  if (p) {
    pending.delete(id)
    if (error) p.reject(new Error(error))
    else p.resolve(result)
  }
}

channel.port2.onmessage = (e) => {
  const { id, method } = e.data
  if (method === 'fail') {
    channel.port2.postMessage({ id, error: 'Intentional failure' })
  } else {
    channel.port2.postMessage({ id, result: 'ok' })
  }
}

channel.port1.start()
channel.port2.start()

const rpc = RPC(transport)

// Success case
const ok = await rpc.success()
expect(ok).toBe('ok')

// Error case
await expect(rpc.fail()).rejects.toThrow('Intentional failure')

// Still works after error
const ok2 = await rpc.successAgain()
expect(ok2).toBe('ok')

channel.port1.close()
channel.port2.close()
```

## Complex Data

```ts test name="structured data via MessageChannel"
import { RPC, type Transport } from 'rpc.do'

const channel = new MessageChannel()
let msgId = 0
const pending = new Map<number, { resolve: Function; reject: Function }>()

const transport: Transport = {
  call(method, args) {
    return new Promise((resolve, reject) => {
      const id = ++msgId
      pending.set(id, { resolve, reject })
      channel.port1.postMessage({ id, method, args })
    })
  }
}

channel.port1.onmessage = (e) => {
  const p = pending.get(e.data.id)
  if (p) {
    pending.delete(e.data.id)
    p.resolve(e.data.result)
  }
}

channel.port2.onmessage = (e) => {
  const { id, method, args } = e.data
  if (method === 'getUser') {
    channel.port2.postMessage({
      id,
      result: {
        id: args[0],
        name: `User ${args[0]}`,
        profile: {
          email: `${args[0]}@example.com`,
          avatar: `https://example.com/avatars/${args[0]}.png`
        }
      }
    })
  }
}

channel.port1.start()
channel.port2.start()

const rpc = RPC(transport)

const user = await rpc.getUser('alice')
expect(user.id).toBe('alice')
expect(user.name).toBe('User alice')
expect(user.profile.email).toBe('alice@example.com')

channel.port1.close()
channel.port2.close()
```

## Run Matrix

```bash
# Run on Node
mdxe test --target node --filter rpc/postmessage

# Run on Workers
mdxe test --target workers --filter rpc/postmessage

# Run on Bun
mdxe test --target bun --filter rpc/postmessage

# All targets
mdxe test --target all --filter rpc/postmessage
```
