---
$type: TestSuite
$id: https://mdx.org.ai/tests/rpc/websocket
title: WebSocket Transport Tests
description: Tests for rpc.do WebSocket transport
---

# WebSocket Transport Tests

Tests for the `ws` transport from `rpc.do`.

## WebSocket Transport Creation

```ts test name="create ws transport"
import { ws } from 'rpc.do'

const transport = ws('wss://api.example.com/rpc')

expect(transport).toBeDefined()
expect(typeof transport.call).toBe('function')
```

```ts test name="ws transport with auth token"
import { ws } from 'rpc.do'

// With static token
const transport = ws('wss://api.example.com/rpc', 'my-api-key')

expect(transport).toBeDefined()
```

```ts test name="ws transport with auth provider"
import { ws } from 'rpc.do'

// With auth provider function
const transport = ws('wss://api.example.com/rpc', async () => {
  return 'dynamic-token'
})

expect(transport).toBeDefined()
```

## WebSocket Transport Close

```ts test name="ws transport has close method"
import { ws } from 'rpc.do'

const transport = ws('wss://api.example.com/rpc')

// Transport may have optional close method
if (transport.close) {
  expect(typeof transport.close).toBe('function')
}
```

## RPC via WebSocket (Mock)

```ts test name="RPC proxy with mock ws-like transport"
import { RPC } from 'rpc.do'

// Simulate WebSocket transport behavior
const mockWsTransport = {
  connected: false,
  async call(method: string, args: any[]) {
    // Simulate connection on first call
    if (!this.connected) {
      this.connected = true
    }

    if (method === 'echo') return args[0]
    if (method === 'chat.send') {
      return { id: 'msg-1', text: args[0].text, sent: true }
    }
    throw new Error(`Unknown method: ${method}`)
  },
  close() {
    this.connected = false
  }
}

const rpc = RPC(mockWsTransport)

const echo = await rpc.echo('websocket test')
expect(echo).toBe('websocket test')

const msg = await rpc.chat.send({ text: 'Hello!' })
expect(msg.sent).toBe(true)
expect(msg.text).toBe('Hello!')

// Clean up
mockWsTransport.close()
expect(mockWsTransport.connected).toBe(false)
```

```ts test name="persistent connection simulation"
import { RPC } from 'rpc.do'

let callCount = 0
const persistentTransport = {
  async call(method: string, args: any[]) {
    callCount++
    return { callNumber: callCount, method }
  }
}

const rpc = RPC(persistentTransport)

// Multiple calls share the same "connection"
const r1 = await rpc.first()
const r2 = await rpc.second()
const r3 = await rpc.third()

expect(r1.callNumber).toBe(1)
expect(r2.callNumber).toBe(2)
expect(r3.callNumber).toBe(3)
```

## Concurrent WebSocket Requests

```ts test name="concurrent requests via ws-like transport"
import { RPC } from 'rpc.do'

const mockTransport = {
  async call(method: string, args: any[]) {
    // Simulate some async work
    await new Promise(r => setTimeout(r, 10))
    if (method === 'compute') {
      return args[0] * 2
    }
    return null
  }
}

const rpc = RPC(mockTransport)

// Fire off concurrent requests
const promises = Array.from({ length: 10 }, (_, i) =>
  rpc.compute(i + 1)
)

const results = await Promise.all(promises)

expect(results).toEqual([2, 4, 6, 8, 10, 12, 14, 16, 18, 20])
```

## Error Recovery

```ts test name="error does not break transport"
import { RPC } from 'rpc.do'

let healthy = true
const resilientTransport = {
  async call(method: string) {
    if (method === 'fail') {
      throw new Error('Intentional failure')
    }
    return { healthy, method }
  }
}

const rpc = RPC(resilientTransport)

// First call succeeds
const r1 = await rpc.check()
expect(r1.healthy).toBe(true)

// This call fails
await expect(rpc.fail()).rejects.toThrow('Intentional failure')

// Transport still works
const r2 = await rpc.checkAgain()
expect(r2.healthy).toBe(true)
```

## Run Matrix

```bash
# Run on Node
mdxe test --target node --filter rpc/websocket

# Run on Workers
mdxe test --target workers --filter rpc/websocket

# Run on Bun
mdxe test --target bun --filter rpc/websocket

# All targets
mdxe test --target all --filter rpc/websocket
```
