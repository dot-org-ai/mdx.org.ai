---
$type: StoryBrand
name: api.ht
tagline: HyperText API
---

# api.ht StoryBrand

## One-Liner

**API.ht helps developers build APIs that work like the web was meant to—where every resource is a URL you can click, browse, and understand.**

---

## The Character (Hero)

**Who is our customer?**

The **pragmatic backend developer** who:
- Has built dozens of REST APIs and knows something is fundamentally wrong
- Spends more time writing OpenAPI specs than actual code
- Deals with clients constantly asking "what's the endpoint for X?"
- Wants APIs that are self-documenting by design

**What do they want?**

APIs that explain themselves. URLs that make sense. Documentation that writes itself. The simplicity of clicking links in a browser, but with full API power.

---

## The Problem

### External Problem (Surface-level)
Modern APIs require extensive documentation, versioning strategies, and client libraries. Consumers can't explore them without reading docs first.

### Internal Problem (Emotional)
"I'm building walls instead of bridges. My API feels like a private club with secret handshakes—even I forget which endpoints exist."

### Philosophical Problem (The "Should")
**APIs should be as navigable as websites.** If the web succeeded because URLs are universal and links are clickable, why did we abandon that for APIs?

### The Villain
**Opacity.** The invisible, undiscoverable nature of modern APIs that forces everyone to RTFM just to make a simple request.

---

## The Guide (Brand Positioning)

### Empathy Statement
We've written the same boilerplate a hundred times—routes, controllers, serializers, OpenAPI annotations—all to expose data that should just... be there.

### Authority
- Built on REST and HATEOAS principles (the parts that actually work)
- Every response includes navigation to related resources
- Automatically generates browsable HTML, JSON, and Markdown from the same endpoint
- Production-proven at scale across multiple organizations

---

## The Plan

### The 3-Step Process

1. **Define Your Resources**
   Write `.mdx` files for each resource type. Define schema, relationships, and behavior in one place.

2. **Deploy the API**
   Every resource gets a URL. Every URL returns content-negotiated responses. HTML for browsers, JSON for code.

3. **Let Users Explore**
   Clients navigate your API like a website. No docs needed—follow the links.

### The Agreement Plan (Trust Builders)
- **Standards-Based**: Built on HTTP semantics that have worked for 30 years
- **Content Negotiation**: Same URL serves JSON, HTML, or Markdown based on Accept header
- **Self-Documenting**: Every response includes links to related resources and actions
- **Cacheable**: Standard HTTP caching works out of the box

---

## The Call to Action

### Direct CTA
**"Build Your First API"** → Interactive example that creates a browsable API in minutes

### Transitional CTAs
- "Browse Example APIs" → Live, clickable API demos
- "See the Spec" → Technical deep-dive on the format
- "Compare Approaches" → Side-by-side with traditional REST

---

## Success (The Transformation)

### Before
- Maintaining Swagger docs separate from code
- Answering "what's the endpoint?" questions daily
- Building custom client libraries for each consumer
- Debugging requests with no context

### After
- Documentation emerges from the API itself
- New team members explore the API in their browser
- Any HTTP client works without special setup
- Errors include links to help and related resources

### Success Visuals
- Browser showing navigable API responses
- curl command followed by clicking a link in the response
- Side-by-side: messy controller code vs. clean MDX definition

---

## Failure (Stakes)

**What happens if they don't act?**

- Another year of maintaining docs that are always out of date
- More friction for every new API consumer
- Continued "undocumented endpoint" bugs in production
- API design that fights against the web instead of leveraging it

---

## Brand Identity

### Voice & Tone
- **Principled but practical**: "This is how the web works, and there's a reason"
- **Technical precision**: Deep respect for HTTP semantics
- **Quietly confident**: Let the approach speak for itself

### Key Messages
1. "Every resource is a URL. Every URL is clickable."
2. "The best documentation is no documentation needed."
3. "APIs that work like the web was meant to."

### Visual Identity
- **Color**: Clean whites and blues (like hyperlinks, like the open web)
- **Aesthetic**: Browser-native, showing actual HTTP responses
- **Imagery**: Browsers, network diagrams, connected resources

---

## Competitive Positioning

| Competitor | Their Approach | Our Difference |
|------------|---------------|----------------|
| GraphQL | Single endpoint, custom query language | Every resource at its own URL |
| REST | Requires separate documentation | Self-documenting by design |
| gRPC | Binary protocol, complex tooling | Text-based, works in any browser |
| tRPC | TypeScript-specific, tightly coupled | Language-agnostic, loosely coupled |

---

## Messaging Matrix

### For Solo Developers
"Build APIs you can actually browse. No Postman required."

### For Teams
"Stop answering 'what endpoint do I use?' Start sharing clickable URLs."

### For API-First Companies
"Your API is your product. Make it explorable from the first request."
