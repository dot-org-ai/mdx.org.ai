/**
 * Deploy command implementation for mdxe
 *
 * Supports deploying Fumadocs/Next.js sites to Cloudflare Workers using:
 * - Static Assets for static data sources (e.g., @mdxdb/fs)
 * - OpenNext.js for dynamic data sources (e.g., @mdxdb/api, @mdxdb/postgres)
 *
 * Supports two deployment methods:
 * - wrangler CLI (default) - uses the standard wrangler deployment flow
 * - Direct API (useApi: true) - uses Cloudflare REST API for custom auth and multi-tenant namespaces
 *
 * @packageDocumentation
 */

import { spawn, spawnSync } from 'node:child_process'
import { existsSync, readFileSync, writeFileSync, mkdirSync, readdirSync, statSync } from 'node:fs'
import { join, resolve, relative } from 'node:path'
import type { CloudflareDeployOptions, DeployResult, SourceTypeInfo } from '../types.js'
import { CloudflareApi, type WorkerMetadata, type WorkerBinding } from '../cloudflare/api.js'
import { ensureLoggedIn } from 'oauth.do'

/**
 * Detect the data source type by analyzing the project configuration
 */
export function detectSourceType(projectDir: string): SourceTypeInfo {
  const sourceConfigPath = join(projectDir, 'source.config.ts')
  const libSourcePath = join(projectDir, 'lib', 'source.ts')
  const srcSourcePath = join(projectDir, 'src', 'lib', 'source.ts')

  // Try to find source configuration
  const configPaths = [sourceConfigPath, libSourcePath, srcSourcePath]
  let configPath: string | undefined
  let configContent: string | undefined

  for (const path of configPaths) {
    if (existsSync(path)) {
      configPath = path
      configContent = readFileSync(path, 'utf-8')
      break
    }
  }

  if (!configContent) {
    // Check package.json dependencies as fallback
    const pkgPath = join(projectDir, 'package.json')
    if (existsSync(pkgPath)) {
      const pkg = JSON.parse(readFileSync(pkgPath, 'utf-8'))
      const deps = { ...pkg.dependencies, ...pkg.devDependencies }

      if (deps['@mdxdb/fs']) {
        return { isStatic: true, adapter: 'fs', configPath }
      }
      if (deps['@mdxdb/api']) {
        return { isStatic: false, adapter: 'api', configPath }
      }
      if (deps['@mdxdb/postgres']) {
        return { isStatic: false, adapter: 'postgres', configPath }
      }
      if (deps['@mdxdb/mongo']) {
        return { isStatic: false, adapter: 'mongo', configPath }
      }
      if (deps['@mdxdb/sqlite']) {
        // SQLite can be static if using D1 or Turso
        return { isStatic: false, adapter: 'sqlite', configPath }
      }
      if (deps['@mdxdb/clickhouse']) {
        return { isStatic: false, adapter: 'clickhouse', configPath }
      }
    }

    return { isStatic: true, adapter: 'unknown', configPath }
  }

  // Analyze source config content
  if (configContent.includes('@mdxdb/fs') || configContent.includes('createFsDatabase')) {
    return { isStatic: true, adapter: 'fs', configPath }
  }
  if (configContent.includes('@mdxdb/api') || configContent.includes('createApiClient')) {
    return { isStatic: false, adapter: 'api', configPath }
  }
  if (configContent.includes('@mdxdb/postgres') || configContent.includes('createDatabase') && configContent.includes('connectionString')) {
    return { isStatic: false, adapter: 'postgres', configPath }
  }
  if (configContent.includes('@mdxdb/mongo')) {
    return { isStatic: false, adapter: 'mongo', configPath }
  }
  if (configContent.includes('@mdxdb/sqlite')) {
    return { isStatic: false, adapter: 'sqlite', configPath }
  }
  if (configContent.includes('@mdxdb/clickhouse')) {
    return { isStatic: false, adapter: 'clickhouse', configPath }
  }

  // Default to static if we can't determine
  return { isStatic: true, adapter: 'unknown', configPath }
}

/**
 * Check if wrangler is installed
 */
function checkWrangler(): boolean {
  const result = spawnSync('npx', ['wrangler', '--version'], {
    stdio: 'pipe',
    shell: true,
  })
  return result.status === 0
}

/**
 * Check if opennextjs-cloudflare is installed
 */
function checkOpenNext(projectDir: string): boolean {
  const pkgPath = join(projectDir, 'package.json')
  if (!existsSync(pkgPath)) return false

  const pkg = JSON.parse(readFileSync(pkgPath, 'utf-8'))
  const deps = { ...pkg.dependencies, ...pkg.devDependencies }
  return !!deps['@opennextjs/cloudflare']
}

/**
 * Generate wrangler.toml for static deployment
 */
function generateStaticWranglerConfig(
  projectDir: string,
  options: CloudflareDeployOptions
): string {
  const projectName = options.projectName || 'mdxe-docs'
  const compatDate = options.compatibilityDate || new Date().toISOString().split('T')[0]

  return `# Generated by mdxe deploy
name = "${projectName}"
main = ".worker/index.js"
compatibility_date = "${compatDate}"

# Static assets configuration
assets = { directory = ".next/static", binding = "ASSETS" }

[build]
command = "npm run build"

# Routes for static site
[[routes]]
pattern = "/*"
zone_name = ""
`
}

/**
 * Generate worker script for static assets
 */
function generateStaticWorkerScript(): string {
  return `// Generated by mdxe deploy - Static Assets Worker
export default {
  async fetch(request, env) {
    const url = new URL(request.url);

    // Try to serve from static assets
    try {
      // Handle index.html for directory requests
      let pathname = url.pathname;
      if (pathname.endsWith('/')) {
        pathname += 'index.html';
      } else if (!pathname.includes('.')) {
        // Try adding .html for clean URLs
        const htmlPath = pathname + '.html';
        const htmlResponse = await env.ASSETS.fetch(new Request(url.origin + htmlPath));
        if (htmlResponse.ok) {
          return htmlResponse;
        }
        // Try as directory
        pathname += '/index.html';
      }

      const response = await env.ASSETS.fetch(new Request(url.origin + pathname));
      if (response.ok) {
        return response;
      }

      // Fallback to 404 page
      const notFoundResponse = await env.ASSETS.fetch(new Request(url.origin + '/404.html'));
      if (notFoundResponse.ok) {
        return new Response(notFoundResponse.body, {
          status: 404,
          headers: notFoundResponse.headers,
        });
      }

      return new Response('Not Found', { status: 404 });
    } catch (error) {
      return new Response('Internal Server Error', { status: 500 });
    }
  },
};
`
}

/**
 * Generate OpenNext configuration
 */
function generateOpenNextConfig(projectDir: string, options: CloudflareDeployOptions): string {
  return `// Generated by mdxe deploy - OpenNext Configuration
import type { OpenNextConfig } from '@opennextjs/cloudflare';

const config: OpenNextConfig = {
  default: {
    override: {
      wrapper: 'cloudflare-node',
      converter: 'edge',
    },
  },
};

export default config;
`
}

/**
 * Run a command and return the result
 */
function runCommand(
  command: string,
  args: string[],
  cwd: string,
  options: { dryRun?: boolean; silent?: boolean } = {}
): Promise<{ success: boolean; output: string; error?: string }> {
  return new Promise((resolve) => {
    if (options.dryRun) {
      console.log(`[dry-run] ${command} ${args.join(' ')}`)
      resolve({ success: true, output: '' })
      return
    }

    const child = spawn(command, args, {
      cwd,
      shell: true,
      stdio: options.silent ? 'pipe' : 'inherit',
    })

    let output = ''
    let errorOutput = ''

    if (options.silent) {
      child.stdout?.on('data', (data) => {
        output += data.toString()
      })
      child.stderr?.on('data', (data) => {
        errorOutput += data.toString()
      })
    }

    child.on('close', (code) => {
      resolve({
        success: code === 0,
        output,
        error: code !== 0 ? errorOutput || `Command exited with code ${code}` : undefined,
      })
    })

    child.on('error', (err) => {
      resolve({
        success: false,
        output,
        error: err.message,
      })
    })
  })
}

/**
 * Deploy using static assets (for static data sources)
 */
async function deployStatic(
  projectDir: string,
  options: CloudflareDeployOptions
): Promise<DeployResult> {
  const logs: string[] = []

  logs.push('Detected static data source - using Cloudflare Workers Static Assets')

  // Check for Next.js project
  const nextConfigPath = join(projectDir, 'next.config.js')
  const nextConfigMjsPath = join(projectDir, 'next.config.mjs')
  const isNextProject = existsSync(nextConfigPath) || existsSync(nextConfigMjsPath)

  if (!isNextProject) {
    return {
      success: false,
      error: 'No Next.js project found. Expected next.config.js or next.config.mjs',
      logs,
    }
  }

  // Step 1: Build Next.js with static export
  logs.push('Building Next.js with static export...')

  // Check/update next.config for static export
  const configPath = existsSync(nextConfigMjsPath) ? nextConfigMjsPath : nextConfigPath
  let nextConfig = readFileSync(configPath, 'utf-8')

  if (!nextConfig.includes("output: 'export'") && !nextConfig.includes('output: "export"')) {
    logs.push('Warning: next.config does not have output: "export". Adding it...')
    // We'll handle this by setting environment variable instead
  }

  const buildResult = await runCommand('npm', ['run', 'build'], projectDir, {
    dryRun: options.dryRun,
  })

  if (!buildResult.success) {
    return {
      success: false,
      error: `Build failed: ${buildResult.error}`,
      logs,
    }
  }
  logs.push('Build completed successfully')

  // Step 2: Generate wrangler config
  const wranglerPath = join(projectDir, 'wrangler.toml')
  if (!existsSync(wranglerPath) || options.force) {
    logs.push('Generating wrangler.toml...')
    const wranglerConfig = generateStaticWranglerConfig(projectDir, options)
    if (!options.dryRun) {
      writeFileSync(wranglerPath, wranglerConfig)
    }
  }

  // Step 3: Generate worker script
  const workerDir = join(projectDir, '.worker')
  const workerPath = join(workerDir, 'index.js')
  if (!existsSync(workerPath) || options.force) {
    logs.push('Generating worker script...')
    if (!options.dryRun) {
      mkdirSync(workerDir, { recursive: true })
      writeFileSync(workerPath, generateStaticWorkerScript())
    }
  }

  // Step 4: Deploy with wrangler
  logs.push('Deploying to Cloudflare Workers...')

  const deployArgs = ['wrangler', 'deploy']
  if (options.dryRun) {
    deployArgs.push('--dry-run')
  }

  const deployResult = await runCommand('npx', deployArgs, projectDir, {
    dryRun: options.dryRun,
    silent: true,
  })

  if (!deployResult.success) {
    return {
      success: false,
      error: `Deployment failed: ${deployResult.error}`,
      logs,
    }
  }

  // Extract URL from output
  const urlMatch = deployResult.output.match(/https:\/\/[^\s]+\.workers\.dev/)
  const url = urlMatch ? urlMatch[0] : undefined

  logs.push(`Deployment successful${url ? `: ${url}` : ''}`)

  return {
    success: true,
    url,
    deploymentId: options.projectName,
    logs,
  }
}

/**
 * Deploy using OpenNext (for dynamic data sources)
 */
async function deployOpenNext(
  projectDir: string,
  options: CloudflareDeployOptions
): Promise<DeployResult> {
  const logs: string[] = []

  logs.push('Detected dynamic data source - using OpenNext.js for Cloudflare')

  // Check if OpenNext is installed
  if (!checkOpenNext(projectDir)) {
    logs.push('Installing @opennextjs/cloudflare...')
    const installResult = await runCommand(
      'npm',
      ['install', '--save-dev', '@opennextjs/cloudflare'],
      projectDir,
      { dryRun: options.dryRun }
    )

    if (!installResult.success) {
      return {
        success: false,
        error: `Failed to install OpenNext: ${installResult.error}`,
        logs,
      }
    }
  }

  // Generate OpenNext config if needed
  const openNextConfigPath = join(projectDir, 'open-next.config.ts')
  if (!existsSync(openNextConfigPath) || options.force) {
    logs.push('Generating open-next.config.ts...')
    if (!options.dryRun) {
      writeFileSync(openNextConfigPath, generateOpenNextConfig(projectDir, options))
    }
  }

  // Generate wrangler.toml for OpenNext
  const wranglerPath = join(projectDir, 'wrangler.toml')
  if (!existsSync(wranglerPath) || options.force) {
    logs.push('Generating wrangler.toml for OpenNext...')
    const projectName = options.projectName || 'mdxe-docs'
    const compatDate = options.compatibilityDate || new Date().toISOString().split('T')[0]

    const wranglerConfig = `# Generated by mdxe deploy - OpenNext Configuration
name = "${projectName}"
main = ".open-next/worker.js"
compatibility_date = "${compatDate}"
compatibility_flags = ["nodejs_compat"]

# Assets for static files
assets = { directory = ".open-next/assets", binding = "ASSETS" }

# KV namespace for cache (optional, create with: wrangler kv:namespace create CACHE)
# [[kv_namespaces]]
# binding = "CACHE"
# id = "your-kv-namespace-id"

[vars]
# Environment variables
${Object.entries(options.env || {})
  .map(([key, value]) => `${key} = "${value}"`)
  .join('\n')}
`

    if (!options.dryRun) {
      writeFileSync(wranglerPath, wranglerConfig)
    }
  }

  // Step 1: Build with OpenNext
  logs.push('Building with OpenNext...')
  const buildResult = await runCommand('npx', ['opennextjs-cloudflare', 'build'], projectDir, {
    dryRun: options.dryRun,
  })

  if (!buildResult.success) {
    return {
      success: false,
      error: `OpenNext build failed: ${buildResult.error}`,
      logs,
    }
  }
  logs.push('OpenNext build completed successfully')

  // Step 2: Deploy with wrangler
  logs.push('Deploying to Cloudflare Workers...')

  const deployArgs = ['wrangler', 'deploy']
  if (options.dryRun) {
    deployArgs.push('--dry-run')
  }

  const deployResult = await runCommand('npx', deployArgs, projectDir, {
    dryRun: options.dryRun,
    silent: true,
  })

  if (!deployResult.success) {
    return {
      success: false,
      error: `Deployment failed: ${deployResult.error}`,
      logs,
    }
  }

  // Extract URL from output
  const urlMatch = deployResult.output.match(/https:\/\/[^\s]+\.workers\.dev/)
  const url = urlMatch ? urlMatch[0] : undefined

  logs.push(`Deployment successful${url ? `: ${url}` : ''}`)

  return {
    success: true,
    url,
    deploymentId: options.projectName,
    logs,
  }
}

/**
 * Create Cloudflare API client from options
 */
function createApiClient(options: CloudflareDeployOptions): CloudflareApi {
  const accountId = options.accountId || process.env.CLOUDFLARE_ACCOUNT_ID
  const apiToken = options.apiToken || process.env.CLOUDFLARE_API_TOKEN

  if (!accountId) {
    throw new Error('Cloudflare account ID is required. Set accountId option or CLOUDFLARE_ACCOUNT_ID env var.')
  }
  if (!apiToken) {
    throw new Error('Cloudflare API token is required. Set apiToken option or CLOUDFLARE_API_TOKEN env var.')
  }

  return new CloudflareApi({
    accountId,
    apiToken,
    baseUrl: options.apiBaseUrl,
    headers: options.apiHeaders,
  })
}

/**
 * Read directory recursively and return all files
 */
function readFilesRecursively(dir: string, basePath: string = ''): Array<{ path: string; content: string }> {
  const files: Array<{ path: string; content: string }> = []

  if (!existsSync(dir)) {
    return files
  }

  const entries = readdirSync(dir)

  for (const entry of entries) {
    const fullPath = join(dir, entry)
    const relativePath = basePath ? `${basePath}/${entry}` : entry
    const stat = statSync(fullPath)

    if (stat.isDirectory()) {
      files.push(...readFilesRecursively(fullPath, relativePath))
    } else {
      files.push({
        path: relativePath,
        content: readFileSync(fullPath, 'utf-8'),
      })
    }
  }

  return files
}

/**
 * Deploy static site using direct Cloudflare API
 */
async function deployStaticViaApi(
  projectDir: string,
  options: CloudflareDeployOptions
): Promise<DeployResult> {
  const logs: string[] = []
  logs.push('Using Cloudflare API for deployment (multi-tenant mode)')

  try {
    const api = createApiClient(options)
    const projectName = options.projectName || 'mdxe-docs'
    const scriptName = options.tenantId ? `${projectName}-${options.tenantId}` : projectName

    // Build Next.js first
    logs.push('Building Next.js with static export...')
    const buildResult = await runCommand('npm', ['run', 'build'], projectDir, {
      dryRun: options.dryRun,
    })

    if (!buildResult.success) {
      return {
        success: false,
        error: `Build failed: ${buildResult.error}`,
        logs,
      }
    }
    logs.push('Build completed successfully')

    // Read the built worker and static files
    const workerDir = join(projectDir, '.worker')
    const workerPath = join(workerDir, 'index.js')

    // Generate worker if not exists
    if (!existsSync(workerPath) || options.force) {
      logs.push('Generating worker script...')
      if (!options.dryRun) {
        mkdirSync(workerDir, { recursive: true })
        writeFileSync(workerPath, generateStaticWorkerScript())
      }
    }

    const workerCode = existsSync(workerPath) ? readFileSync(workerPath, 'utf-8') : generateStaticWorkerScript()

    // Prepare bindings
    const bindings: WorkerBinding[] = [
      { type: 'assets', name: 'ASSETS' },
    ]

    // Add KV namespace bindings
    if (options.kvNamespaces) {
      for (const [name, namespaceId] of Object.entries(options.kvNamespaces)) {
        bindings.push({ type: 'kv_namespace', name, namespace_id: namespaceId })
      }
    }

    // Add D1 bindings
    if (options.d1Databases) {
      for (const [name, id] of Object.entries(options.d1Databases)) {
        bindings.push({ type: 'd1', name, id })
      }
    }

    // Add environment variables
    if (options.env) {
      for (const [name, text] of Object.entries(options.env)) {
        bindings.push({ type: 'plain_text', name, text })
      }
    }

    const metadata: WorkerMetadata = {
      main_module: 'worker.js',
      compatibility_date: options.compatibilityDate || new Date().toISOString().split('T')[0],
      compatibility_flags: options.compatibilityFlags,
      bindings,
    }

    if (options.dryRun) {
      logs.push(`[dry-run] Would upload worker '${scriptName}' to Cloudflare`)
      if (options.dispatchNamespace) {
        logs.push(`[dry-run] Would use dispatch namespace: ${options.dispatchNamespace}`)
      }
      return {
        success: true,
        logs,
      }
    }

    // Upload to dispatch namespace or directly
    let result
    if (options.dispatchNamespace) {
      logs.push(`Deploying to dispatch namespace: ${options.dispatchNamespace}`)
      result = await api.uploadToNamespace(
        options.dispatchNamespace,
        scriptName,
        workerCode,
        metadata
      )
    } else {
      logs.push('Deploying worker...')
      result = await api.uploadWorker(scriptName, workerCode, metadata)
    }

    if (!result.success) {
      return {
        success: false,
        error: `Deployment failed: ${result.errors?.map(e => e.message).join(', ')}`,
        logs,
      }
    }

    logs.push(`Deployment successful${result.url ? `: ${result.url}` : ''}`)

    return {
      success: true,
      url: result.url,
      deploymentId: result.scriptId,
      logs,
    }
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
      logs,
    }
  }
}

/**
 * Deploy using OpenNext via direct Cloudflare API
 */
async function deployOpenNextViaApi(
  projectDir: string,
  options: CloudflareDeployOptions
): Promise<DeployResult> {
  const logs: string[] = []
  logs.push('Using Cloudflare API for OpenNext deployment (multi-tenant mode)')

  try {
    const api = createApiClient(options)
    const projectName = options.projectName || 'mdxe-docs'
    const scriptName = options.tenantId ? `${projectName}-${options.tenantId}` : projectName

    // Check if OpenNext is installed
    if (!checkOpenNext(projectDir)) {
      logs.push('Installing @opennextjs/cloudflare...')
      const installResult = await runCommand(
        'npm',
        ['install', '--save-dev', '@opennextjs/cloudflare'],
        projectDir,
        { dryRun: options.dryRun }
      )

      if (!installResult.success) {
        return {
          success: false,
          error: `Failed to install OpenNext: ${installResult.error}`,
          logs,
        }
      }
    }

    // Generate OpenNext config if needed
    const openNextConfigPath = join(projectDir, 'open-next.config.ts')
    if (!existsSync(openNextConfigPath) || options.force) {
      logs.push('Generating open-next.config.ts...')
      if (!options.dryRun) {
        writeFileSync(openNextConfigPath, generateOpenNextConfig(projectDir, options))
      }
    }

    // Build with OpenNext
    logs.push('Building with OpenNext...')
    const buildResult = await runCommand('npx', ['opennextjs-cloudflare', 'build'], projectDir, {
      dryRun: options.dryRun,
    })

    if (!buildResult.success) {
      return {
        success: false,
        error: `OpenNext build failed: ${buildResult.error}`,
        logs,
      }
    }
    logs.push('OpenNext build completed successfully')

    // Read the built worker
    const workerPath = join(projectDir, '.open-next', 'worker.js')
    if (!existsSync(workerPath) && !options.dryRun) {
      return {
        success: false,
        error: 'OpenNext worker not found at .open-next/worker.js',
        logs,
      }
    }

    const workerCode = existsSync(workerPath) ? readFileSync(workerPath, 'utf-8') : ''

    // Prepare bindings
    const bindings: WorkerBinding[] = [
      { type: 'assets', name: 'ASSETS' },
    ]

    // Add KV namespace bindings
    if (options.kvNamespaces) {
      for (const [name, namespaceId] of Object.entries(options.kvNamespaces)) {
        bindings.push({ type: 'kv_namespace', name, namespace_id: namespaceId })
      }
    }

    // Add D1 bindings
    if (options.d1Databases) {
      for (const [name, id] of Object.entries(options.d1Databases)) {
        bindings.push({ type: 'd1', name, id })
      }
    }

    // Add environment variables
    if (options.env) {
      for (const [name, text] of Object.entries(options.env)) {
        bindings.push({ type: 'plain_text', name, text })
      }
    }

    const metadata: WorkerMetadata = {
      main_module: 'worker.js',
      compatibility_date: options.compatibilityDate || new Date().toISOString().split('T')[0],
      compatibility_flags: options.compatibilityFlags || ['nodejs_compat'],
      bindings,
    }

    if (options.dryRun) {
      logs.push(`[dry-run] Would upload OpenNext worker '${scriptName}' to Cloudflare`)
      if (options.dispatchNamespace) {
        logs.push(`[dry-run] Would use dispatch namespace: ${options.dispatchNamespace}`)
      }
      return {
        success: true,
        logs,
      }
    }

    // Upload to dispatch namespace or directly
    let result
    if (options.dispatchNamespace) {
      logs.push(`Deploying to dispatch namespace: ${options.dispatchNamespace}`)
      result = await api.uploadToNamespace(
        options.dispatchNamespace,
        scriptName,
        workerCode,
        metadata
      )
    } else {
      logs.push('Deploying worker...')
      result = await api.uploadWorker(scriptName, workerCode, metadata)
    }

    if (!result.success) {
      return {
        success: false,
        error: `Deployment failed: ${result.errors?.map(e => e.message).join(', ')}`,
        logs,
      }
    }

    logs.push(`Deployment successful${result.url ? `: ${result.url}` : ''}`)

    return {
      success: true,
      url: result.url,
      deploymentId: result.scriptId,
      logs,
    }
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
      logs,
    }
  }
}

/**
 * Deploy via managed workers.do API
 * Uses oauth.do for authentication and POSTs to /workers endpoint
 */
async function deployViaManagedApi(
  projectDir: string,
  options: CloudflareDeployOptions
): Promise<DeployResult> {
  const logs: string[] = []
  logs.push('Using managed workers.do API for deployment')

  const managedApiUrl = options.managedApiUrl || process.env.WORKERS_API_URL || 'https://apis.do'

  try {
    // Get authentication token
    let token: string
    if (options.dryRun) {
      token = 'dry-run-token'
      logs.push('Skipping authentication (dry run)')
    } else {
      logs.push('Authenticating via oauth.do...')
      const auth = await ensureLoggedIn()
      token = auth.token
      logs.push(auth.isNewLogin ? 'Logged in successfully' : 'Using existing session')
    }

    // Detect source type
    const sourceType = detectSourceType(projectDir)
    logs.push(`Detected adapter: ${sourceType.adapter || 'unknown'}`)

    // Determine deployment mode
    const mode = options.mode || (sourceType.isStatic ? 'static' : 'opennext')
    logs.push(`Deployment mode: ${mode}`)

    // Build the project first
    logs.push('Building project...')
    const buildResult = await runCommand('npm', ['run', 'build'], projectDir, {
      dryRun: options.dryRun,
    })

    if (!buildResult.success) {
      return {
        success: false,
        error: `Build failed: ${buildResult.error}`,
        logs,
      }
    }
    logs.push('Build completed successfully')

    // Read the built worker code
    let workerCode: string
    const workerDir = join(projectDir, '.worker')
    const workerPath = join(workerDir, 'index.js')
    const openNextWorkerPath = join(projectDir, '.open-next', 'worker.js')

    if (mode === 'opennext' && existsSync(openNextWorkerPath)) {
      workerCode = readFileSync(openNextWorkerPath, 'utf-8')
    } else if (existsSync(workerPath)) {
      workerCode = readFileSync(workerPath, 'utf-8')
    } else {
      // Generate a basic worker if none exists
      if (!options.dryRun) {
        mkdirSync(workerDir, { recursive: true })
        writeFileSync(workerPath, generateStaticWorkerScript())
      }
      workerCode = generateStaticWorkerScript()
    }

    // Collect static assets if available
    const assetsDir = mode === 'opennext'
      ? join(projectDir, '.open-next', 'assets')
      : join(projectDir, '.next', 'static')

    const assets = existsSync(assetsDir)
      ? readFilesRecursively(assetsDir)
      : []

    logs.push(`Found ${assets.length} static asset(s)`)

    // Prepare the deployment payload
    const payload = {
      name: options.projectName || 'mdxe-worker',
      code: workerCode,
      mode,
      compatibilityDate: options.compatibilityDate || new Date().toISOString().split('T')[0],
      compatibilityFlags: options.compatibilityFlags,
      env: options.env,
      kvNamespaces: options.kvNamespaces,
      d1Databases: options.d1Databases,
      r2Buckets: options.r2Buckets,
      dispatchNamespace: options.dispatchNamespace,
      tenantId: options.tenantId,
      assets: assets.map(a => ({ path: a.path, content: a.content })),
    }

    if (options.dryRun) {
      logs.push(`[dry-run] Would POST to ${managedApiUrl}/workers`)
      logs.push(`[dry-run] Worker name: ${payload.name}`)
      logs.push(`[dry-run] Mode: ${payload.mode}`)
      logs.push(`[dry-run] Assets: ${assets.length} files`)
      return {
        success: true,
        logs,
      }
    }

    // POST to /workers endpoint
    logs.push(`Deploying to ${managedApiUrl}/workers...`)

    const response = await fetch(`${managedApiUrl}/workers`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`,
      },
      body: JSON.stringify(payload),
    })

    if (!response.ok) {
      const error = await response.text()
      throw new Error(`HTTP ${response.status}: ${error}`)
    }

    const result = await response.json() as {
      success: boolean
      url?: string
      deploymentId?: string
      error?: string
    }

    if (result.success) {
      logs.push(`Deployment successful${result.url ? `: ${result.url}` : ''}`)
      return {
        success: true,
        url: result.url,
        deploymentId: result.deploymentId,
        logs,
      }
    } else {
      throw new Error(result.error || 'Unknown error')
    }
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
      logs,
    }
  }
}

/**
 * Main deploy function
 */
export async function deploy(
  projectDir: string,
  options: CloudflareDeployOptions = { platform: 'cloudflare' }
): Promise<DeployResult> {
  const resolvedDir = resolve(projectDir)
  const logs: string[] = []

  // Detect source type
  const sourceType = detectSourceType(resolvedDir)
  logs.push(`Detected adapter: ${sourceType.adapter || 'unknown'}`)
  logs.push(`Static source: ${sourceType.isStatic}`)

  // Determine deployment mode
  const mode = options.mode || (sourceType.isStatic ? 'static' : 'opennext')
  logs.push(`Deployment mode: ${mode}`)

  // Always use managed apis.do API for deployment (oauth.do auth)
  // Skip only if useApi is explicitly set (for custom Cloudflare auth)
  if (!options.useApi) {
    const result = await deployViaManagedApi(resolvedDir, options)
    return {
      ...result,
      logs: [...logs, ...(result.logs || [])],
    }
  }

  // Use direct Cloudflare API deployment if requested (for custom auth / multi-tenant)
  if (options.useApi) {
    logs.push('Using direct Cloudflare API (custom auth / multi-tenant mode)')

    if (mode === 'static') {
      const result = await deployStaticViaApi(resolvedDir, options)
      return {
        ...result,
        logs: [...logs, ...(result.logs || [])],
      }
    } else {
      const result = await deployOpenNextViaApi(resolvedDir, options)
      return {
        ...result,
        logs: [...logs, ...(result.logs || [])],
      }
    }
  }

  // Default: Use wrangler CLI
  // Check wrangler is available
  if (!checkWrangler()) {
    return {
      success: false,
      error: 'wrangler is not installed. Install it with: npm install -D wrangler',
      logs,
    }
  }
  logs.push('wrangler found')

  // Deploy based on mode
  if (mode === 'static') {
    const result = await deployStatic(resolvedDir, options)
    return {
      ...result,
      logs: [...logs, ...(result.logs || [])],
    }
  } else {
    const result = await deployOpenNext(resolvedDir, options)
    return {
      ...result,
      logs: [...logs, ...(result.logs || [])],
    }
  }
}

export type { CloudflareDeployOptions, DeployResult, SourceTypeInfo }
