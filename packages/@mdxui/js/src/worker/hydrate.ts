/**
 * Selective Hydration Script Generator
 *
 * Generates minimal hydration scripts that only import and hydrate
 * specified components marked with data-hydrate attributes.
 *
 * @example
 * ```html
 * <!-- HTML with data-hydrate attribute -->
 * <div data-hydrate="Counter" data-props='{"initial":5}'></div>
 *
 * <!-- Load hydration script -->
 * <script src="/hydrate?components=Counter"></script>
 * ```
 *
 * The script will:
 * 1. Only import the Counter component (tree-shaken)
 * 2. Find all elements with data-hydrate="Counter"
 * 3. Hydrate each element with the component and props
 * 4. Minimal runtime footprint (2.8KB Hono JSX DOM + components)
 */

/**
 * Component registry type
 */
interface ComponentModule {
  [key: string]: any
}

/**
 * Generate selective hydration script
 *
 * @param components - List of component names to hydrate
 * @returns JavaScript code as a string
 */
export function generateHydrateScript(components: string[]): string {
  // If no components specified, return minimal script
  if (components.length === 0) {
    return `// No components to hydrate
console.log('[mdxui/js] No components specified for hydration');`
  }

  // Deduplicate and validate component names
  const uniqueComponents = Array.from(new Set(components)).filter(name => {
    // Basic validation: alphanumeric and common characters
    return /^[A-Za-z][A-Za-z0-9_]*$/.test(name)
  })

  if (uniqueComponents.length === 0) {
    return `// Invalid component names
console.error('[mdxui/js] No valid component names provided');`
  }

  // Generate dynamic import statements
  const imports = uniqueComponents
    .map(name => `  '${name}': () => import('/components/${name}.js')`)
    .join(',\n')

  // Generate the hydration script
  return `/**
 * Selective Hydration Script
 * Components: ${uniqueComponents.join(', ')}
 * Generated by @mdxui/js Worker
 */

(async function() {
  'use strict';

  // Component registry with dynamic imports
  const componentModules = {
${imports}
  };

  // Loaded components cache
  const loadedComponents = {};

  /**
   * Load a component module
   */
  async function loadComponent(name) {
    if (loadedComponents[name]) {
      return loadedComponents[name];
    }

    const loader = componentModules[name];
    if (!loader) {
      console.error(\`[mdxui/js] Unknown component: \${name}\`);
      return null;
    }

    try {
      const module = await loader();
      loadedComponents[name] = module[name] || module.default;
      return loadedComponents[name];
    } catch (error) {
      console.error(\`[mdxui/js] Failed to load component \${name}:\`, error);
      return null;
    }
  }

  /**
   * Parse props from data-props attribute
   */
  function parseProps(element) {
    const propsAttr = element.getAttribute('data-props');
    if (!propsAttr) return {};

    try {
      return JSON.parse(propsAttr);
    } catch (error) {
      console.error('[mdxui/js] Failed to parse data-props:', error);
      return {};
    }
  }

  /**
   * Hydrate a single element
   */
  async function hydrateElement(element, componentName) {
    const Component = await loadComponent(componentName);
    if (!Component) return;

    const props = parseProps(element);

    try {
      // Import render function from runtime
      const { render } = await import('/runtime');

      // Render component into element
      render(Component(props), element);

      // Mark as hydrated
      element.setAttribute('data-hydrated', 'true');

      console.log(\`[mdxui/js] Hydrated \${componentName}\`, element);
    } catch (error) {
      console.error(\`[mdxui/js] Failed to hydrate \${componentName}:\`, error);
    }
  }

  /**
   * Find and hydrate all components
   */
  async function hydrateAll() {
    const components = [${uniqueComponents.map(name => `'${name}'`).join(', ')}];

    for (const componentName of components) {
      const elements = document.querySelectorAll(\`[data-hydrate="\${componentName}"]\`);

      for (const element of elements) {
        // Skip already hydrated elements
        if (element.getAttribute('data-hydrated') === 'true') {
          continue;
        }

        await hydrateElement(element, componentName);
      }
    }
  }

  /**
   * Observe new elements added to the DOM
   */
  function observeNewElements() {
    const observer = new MutationObserver((mutations) => {
      for (const mutation of mutations) {
        for (const node of mutation.addedNodes) {
          if (node.nodeType !== Node.ELEMENT_NODE) continue;

          const element = node;
          const hydrate = element.getAttribute('data-hydrate');

          if (hydrate && componentModules[hydrate] && element.getAttribute('data-hydrated') !== 'true') {
            hydrateElement(element, hydrate);
          }

          // Check descendants
          const descendants = element.querySelectorAll('[data-hydrate]');
          for (const desc of descendants) {
            const descHydrate = desc.getAttribute('data-hydrate');
            if (descHydrate && componentModules[descHydrate] && desc.getAttribute('data-hydrated') !== 'true') {
              hydrateElement(desc, descHydrate);
            }
          }
        }
      }
    });

    observer.observe(document.body, {
      childList: true,
      subtree: true,
    });

    return observer;
  }

  // Wait for DOM to be ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', async () => {
      await hydrateAll();
      observeNewElements();
    });
  } else {
    await hydrateAll();
    observeNewElements();
  }

  console.log('[mdxui/js] Hydration script loaded');
})();
`
}

/**
 * Generate a minimal inline hydration snippet
 *
 * This is a smaller version for embedding directly in HTML <script> tags
 * when you want to avoid an extra HTTP request.
 *
 * @param components - List of component names to hydrate
 * @returns Minified JavaScript code
 */
export function generateInlineHydrateScript(components: string[]): string {
  const uniqueComponents = Array.from(new Set(components)).filter(name =>
    /^[A-Za-z][A-Za-z0-9_]*$/.test(name)
  )

  if (uniqueComponents.length === 0) {
    return ''
  }

  // Minified version for inline use
  return `(async()=>{const c={${uniqueComponents.map(n => `'${n}':()=>import('/components/${n}.js')`).join(',')}},l={};async function h(e,n){const t=l[n]||(l[n]=await c[n]().then(m=>m[n]||m.default));if(!t)return;const p=e.getAttribute('data-props');const r=await import('/runtime');r.render(t(p?JSON.parse(p):{}),e);e.setAttribute('data-hydrated','true')}async function a(){for(const n of[${uniqueComponents.map(n => `'${n}'`).join(',')}]){const e=document.querySelectorAll(\`[data-hydrate="\${n}"]:not([data-hydrated])\`);for(const el of e)await h(el,n)}}document.readyState==='loading'?document.addEventListener('DOMContentLoaded',a):a()})();`
}
