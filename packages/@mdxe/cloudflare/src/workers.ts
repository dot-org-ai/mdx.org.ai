/**
 * @mdxe/cloudflare - Cloudflare Workers Deployment
 *
 * Deploy MDX projects to Cloudflare Workers with support for:
 * - Static assets via Workers Static Assets
 * - SSR via OpenNext.js
 * - Multi-tenant via Workers for Platforms
 *
 * @packageDocumentation
 */

import { spawn, spawnSync } from 'node:child_process'
import { existsSync, readFileSync, writeFileSync, mkdirSync, readdirSync, statSync } from 'node:fs'
import { join, resolve } from 'node:path'
import type {
  CloudflareWorkersOptions,
  DeployResult,
  SourceTypeInfo,
  WorkerBinding,
  WorkerMetadata,
} from './types.js'
import { CloudflareApi } from './api.js'

/**
 * Detect the data source type by analyzing the project configuration
 */
export function detectSourceType(projectDir: string): SourceTypeInfo {
  const sourceConfigPath = join(projectDir, 'source.config.ts')
  const libSourcePath = join(projectDir, 'lib', 'source.ts')
  const srcSourcePath = join(projectDir, 'src', 'lib', 'source.ts')

  const configPaths = [sourceConfigPath, libSourcePath, srcSourcePath]
  let configPath: string | undefined
  let configContent: string | undefined

  for (const path of configPaths) {
    if (existsSync(path)) {
      configPath = path
      configContent = readFileSync(path, 'utf-8')
      break
    }
  }

  if (!configContent) {
    const pkgPath = join(projectDir, 'package.json')
    if (existsSync(pkgPath)) {
      const pkg = JSON.parse(readFileSync(pkgPath, 'utf-8'))
      const deps = { ...pkg.dependencies, ...pkg.devDependencies }

      if (deps['@mdxdb/fs']) return { isStatic: true, adapter: 'fs', configPath }
      if (deps['@mdxdb/api']) return { isStatic: false, adapter: 'api', configPath }
      if (deps['@mdxdb/postgres']) return { isStatic: false, adapter: 'postgres', configPath }
      if (deps['@mdxdb/mongo']) return { isStatic: false, adapter: 'mongo', configPath }
      if (deps['@mdxdb/sqlite']) return { isStatic: false, adapter: 'sqlite', configPath }
      if (deps['@mdxdb/clickhouse']) return { isStatic: false, adapter: 'clickhouse', configPath }
    }
    return { isStatic: true, adapter: 'unknown', configPath }
  }

  if (configContent.includes('@mdxdb/fs') || configContent.includes('createFsDatabase')) {
    return { isStatic: true, adapter: 'fs', configPath }
  }
  if (configContent.includes('@mdxdb/api') || configContent.includes('createApiClient')) {
    return { isStatic: false, adapter: 'api', configPath }
  }
  if (configContent.includes('@mdxdb/postgres') || (configContent.includes('createDatabase') && configContent.includes('connectionString'))) {
    return { isStatic: false, adapter: 'postgres', configPath }
  }
  if (configContent.includes('@mdxdb/mongo')) {
    return { isStatic: false, adapter: 'mongo', configPath }
  }
  if (configContent.includes('@mdxdb/sqlite')) {
    return { isStatic: false, adapter: 'sqlite', configPath }
  }
  if (configContent.includes('@mdxdb/clickhouse')) {
    return { isStatic: false, adapter: 'clickhouse', configPath }
  }

  return { isStatic: true, adapter: 'unknown', configPath }
}

/**
 * Check if wrangler is installed
 */
function checkWrangler(): boolean {
  const result = spawnSync('npx', ['wrangler', '--version'], {
    stdio: 'pipe',
    shell: true,
  })
  return result.status === 0
}

/**
 * Check if opennextjs-cloudflare is installed
 */
function checkOpenNext(projectDir: string): boolean {
  const pkgPath = join(projectDir, 'package.json')
  if (!existsSync(pkgPath)) return false

  const pkg = JSON.parse(readFileSync(pkgPath, 'utf-8'))
  const deps = { ...pkg.dependencies, ...pkg.devDependencies }
  return !!deps['@opennextjs/cloudflare']
}

/**
 * Generate wrangler.toml for static deployment
 */
function generateStaticWranglerConfig(options: CloudflareWorkersOptions): string {
  const projectName = options.projectName || 'mdxe-worker'
  const compatDate = options.compatibilityDate || new Date().toISOString().split('T')[0]

  return `# Generated by @mdxe/cloudflare
name = "${projectName}"
main = ".worker/index.js"
compatibility_date = "${compatDate}"

# Static assets configuration
assets = { directory = ".next/static", binding = "ASSETS" }

[build]
command = "npm run build"

# Routes for static site
[[routes]]
pattern = "/*"
zone_name = ""
`
}

/**
 * Generate worker script for static assets
 */
function generateStaticWorkerScript(): string {
  return `// Generated by @mdxe/cloudflare - Static Assets Worker
export default {
  async fetch(request, env) {
    const url = new URL(request.url);

    try {
      let pathname = url.pathname;
      if (pathname.endsWith('/')) {
        pathname += 'index.html';
      } else if (!pathname.includes('.')) {
        const htmlPath = pathname + '.html';
        const htmlResponse = await env.ASSETS.fetch(new Request(url.origin + htmlPath));
        if (htmlResponse.ok) {
          return htmlResponse;
        }
        pathname += '/index.html';
      }

      const response = await env.ASSETS.fetch(new Request(url.origin + pathname));
      if (response.ok) {
        return response;
      }

      const notFoundResponse = await env.ASSETS.fetch(new Request(url.origin + '/404.html'));
      if (notFoundResponse.ok) {
        return new Response(notFoundResponse.body, {
          status: 404,
          headers: notFoundResponse.headers,
        });
      }

      return new Response('Not Found', { status: 404 });
    } catch (error) {
      return new Response('Internal Server Error', { status: 500 });
    }
  },
};
`
}

/**
 * Generate OpenNext configuration
 */
function generateOpenNextConfig(): string {
  return `// Generated by @mdxe/cloudflare - OpenNext Configuration
import type { OpenNextConfig } from '@opennextjs/cloudflare';

const config: OpenNextConfig = {
  default: {
    override: {
      wrapper: 'cloudflare-node',
      converter: 'edge',
    },
  },
};

export default config;
`
}

/**
 * Run a command and return the result
 */
function runCommand(
  command: string,
  args: string[],
  cwd: string,
  options: { dryRun?: boolean; silent?: boolean } = {}
): Promise<{ success: boolean; output: string; error?: string }> {
  return new Promise((resolve) => {
    if (options.dryRun) {
      console.log(`[dry-run] ${command} ${args.join(' ')}`)
      resolve({ success: true, output: '' })
      return
    }

    const child = spawn(command, args, {
      cwd,
      shell: true,
      stdio: options.silent ? 'pipe' : 'inherit',
    })

    let output = ''
    let errorOutput = ''

    if (options.silent) {
      child.stdout?.on('data', (data) => {
        output += data.toString()
      })
      child.stderr?.on('data', (data) => {
        errorOutput += data.toString()
      })
    }

    child.on('close', (code) => {
      resolve({
        success: code === 0,
        output,
        error: code !== 0 ? errorOutput || `Command exited with code ${code}` : undefined,
      })
    })

    child.on('error', (err) => {
      resolve({
        success: false,
        output,
        error: err.message,
      })
    })
  })
}

/**
 * Read directory recursively and return all files
 */
function readFilesRecursively(dir: string, basePath: string = ''): Array<{ path: string; content: string }> {
  const files: Array<{ path: string; content: string }> = []

  if (!existsSync(dir)) {
    return files
  }

  const entries = readdirSync(dir)

  for (const entry of entries) {
    const fullPath = join(dir, entry)
    const relativePath = basePath ? `${basePath}/${entry}` : entry
    const stat = statSync(fullPath)

    if (stat.isDirectory()) {
      files.push(...readFilesRecursively(fullPath, relativePath))
    } else {
      files.push({
        path: relativePath,
        content: readFileSync(fullPath, 'utf-8'),
      })
    }
  }

  return files
}

/**
 * Create Cloudflare API client from options
 */
function createApiClient(options: CloudflareWorkersOptions): CloudflareApi {
  const accountId = options.accountId || process.env.CLOUDFLARE_ACCOUNT_ID
  const apiToken = options.apiToken || process.env.CLOUDFLARE_API_TOKEN

  if (!accountId) {
    throw new Error('Cloudflare account ID is required. Set accountId option or CLOUDFLARE_ACCOUNT_ID env var.')
  }
  if (!apiToken) {
    throw new Error('Cloudflare API token is required. Set apiToken option or CLOUDFLARE_API_TOKEN env var.')
  }

  return new CloudflareApi({
    accountId,
    apiToken,
    baseUrl: options.apiBaseUrl,
    headers: options.apiHeaders,
  })
}

/**
 * Deploy static site using wrangler CLI
 */
async function deployStaticWithWrangler(options: CloudflareWorkersOptions): Promise<DeployResult> {
  const projectDir = resolve(options.projectDir)
  const logs: string[] = []

  logs.push('Detected static data source - using Cloudflare Workers Static Assets')

  const nextConfigPath = join(projectDir, 'next.config.js')
  const nextConfigMjsPath = join(projectDir, 'next.config.mjs')
  const isNextProject = existsSync(nextConfigPath) || existsSync(nextConfigMjsPath)

  if (!isNextProject) {
    return {
      success: false,
      error: 'No Next.js project found. Expected next.config.js or next.config.mjs',
      logs,
      type: 'workers',
    }
  }

  logs.push('Building Next.js with static export...')
  const buildResult = await runCommand('npm', ['run', 'build'], projectDir, { dryRun: options.dryRun })

  if (!buildResult.success) {
    return { success: false, error: `Build failed: ${buildResult.error}`, logs, type: 'workers' }
  }
  logs.push('Build completed successfully')

  const wranglerPath = join(projectDir, 'wrangler.toml')
  if (!existsSync(wranglerPath) || options.force) {
    logs.push('Generating wrangler.toml...')
    if (!options.dryRun) {
      writeFileSync(wranglerPath, generateStaticWranglerConfig(options))
    }
  }

  const workerDir = join(projectDir, '.worker')
  const workerPath = join(workerDir, 'index.js')
  if (!existsSync(workerPath) || options.force) {
    logs.push('Generating worker script...')
    if (!options.dryRun) {
      mkdirSync(workerDir, { recursive: true })
      writeFileSync(workerPath, generateStaticWorkerScript())
    }
  }

  logs.push('Deploying to Cloudflare Workers...')

  const deployArgs = ['wrangler', 'deploy']
  if (options.dryRun) {
    deployArgs.push('--dry-run')
  }

  const deployResult = await runCommand('npx', deployArgs, projectDir, { dryRun: options.dryRun, silent: true })

  if (!deployResult.success) {
    return { success: false, error: `Deployment failed: ${deployResult.error}`, logs, type: 'workers' }
  }

  const urlMatch = deployResult.output.match(/https:\/\/[^\s]+\.workers\.dev/)
  const url = urlMatch ? urlMatch[0] : undefined

  logs.push(`Deployment successful${url ? `: ${url}` : ''}`)

  return { success: true, url, deploymentId: options.projectName, logs, type: 'workers' }
}

/**
 * Deploy using OpenNext with wrangler CLI
 */
async function deployOpenNextWithWrangler(options: CloudflareWorkersOptions): Promise<DeployResult> {
  const projectDir = resolve(options.projectDir)
  const logs: string[] = []

  logs.push('Detected dynamic data source - using OpenNext.js for Cloudflare')

  if (!checkOpenNext(projectDir)) {
    logs.push('Installing @opennextjs/cloudflare...')
    const installResult = await runCommand(
      'npm',
      ['install', '--save-dev', '@opennextjs/cloudflare'],
      projectDir,
      { dryRun: options.dryRun }
    )

    if (!installResult.success) {
      return { success: false, error: `Failed to install OpenNext: ${installResult.error}`, logs, type: 'workers' }
    }
  }

  const openNextConfigPath = join(projectDir, 'open-next.config.ts')
  if (!existsSync(openNextConfigPath) || options.force) {
    logs.push('Generating open-next.config.ts...')
    if (!options.dryRun) {
      writeFileSync(openNextConfigPath, generateOpenNextConfig())
    }
  }

  const wranglerPath = join(projectDir, 'wrangler.toml')
  if (!existsSync(wranglerPath) || options.force) {
    logs.push('Generating wrangler.toml for OpenNext...')
    const projectName = options.projectName || 'mdxe-worker'
    const compatDate = options.compatibilityDate || new Date().toISOString().split('T')[0]

    const wranglerConfig = `# Generated by @mdxe/cloudflare - OpenNext Configuration
name = "${projectName}"
main = ".open-next/worker.js"
compatibility_date = "${compatDate}"
compatibility_flags = ["nodejs_compat"]

assets = { directory = ".open-next/assets", binding = "ASSETS" }

[vars]
${Object.entries(options.env || {}).map(([key, value]) => `${key} = "${value}"`).join('\n')}
`

    if (!options.dryRun) {
      writeFileSync(wranglerPath, wranglerConfig)
    }
  }

  logs.push('Building with OpenNext...')
  const buildResult = await runCommand('npx', ['opennextjs-cloudflare', 'build'], projectDir, { dryRun: options.dryRun })

  if (!buildResult.success) {
    return { success: false, error: `OpenNext build failed: ${buildResult.error}`, logs, type: 'workers' }
  }
  logs.push('OpenNext build completed successfully')

  logs.push('Deploying to Cloudflare Workers...')

  const deployArgs = ['wrangler', 'deploy']
  if (options.dryRun) {
    deployArgs.push('--dry-run')
  }

  const deployResult = await runCommand('npx', deployArgs, projectDir, { dryRun: options.dryRun, silent: true })

  if (!deployResult.success) {
    return { success: false, error: `Deployment failed: ${deployResult.error}`, logs, type: 'workers' }
  }

  const urlMatch = deployResult.output.match(/https:\/\/[^\s]+\.workers\.dev/)
  const url = urlMatch ? urlMatch[0] : undefined

  logs.push(`Deployment successful${url ? `: ${url}` : ''}`)

  return { success: true, url, deploymentId: options.projectName, logs, type: 'workers' }
}

/**
 * Deploy static site using direct API
 */
async function deployStaticWithApi(options: CloudflareWorkersOptions): Promise<DeployResult> {
  const projectDir = resolve(options.projectDir)
  const logs: string[] = []
  logs.push('Using Cloudflare API for deployment')

  try {
    const api = createApiClient(options)
    const projectName = options.projectName || 'mdxe-worker'
    const scriptName = options.tenantId ? `${projectName}-${options.tenantId}` : projectName

    logs.push('Building project...')
    const buildResult = await runCommand('npm', ['run', 'build'], projectDir, { dryRun: options.dryRun })

    if (!buildResult.success) {
      return { success: false, error: `Build failed: ${buildResult.error}`, logs, type: 'workers' }
    }
    logs.push('Build completed successfully')

    const workerDir = join(projectDir, '.worker')
    const workerPath = join(workerDir, 'index.js')

    if (!existsSync(workerPath) || options.force) {
      logs.push('Generating worker script...')
      if (!options.dryRun) {
        mkdirSync(workerDir, { recursive: true })
        writeFileSync(workerPath, generateStaticWorkerScript())
      }
    }

    const workerCode = existsSync(workerPath) ? readFileSync(workerPath, 'utf-8') : generateStaticWorkerScript()

    const bindings: WorkerBinding[] = [{ type: 'assets', name: 'ASSETS' }]

    if (options.kvNamespaces) {
      for (const [name, namespaceId] of Object.entries(options.kvNamespaces)) {
        bindings.push({ type: 'kv_namespace', name, namespace_id: namespaceId })
      }
    }

    if (options.d1Databases) {
      for (const [name, id] of Object.entries(options.d1Databases)) {
        bindings.push({ type: 'd1', name, id })
      }
    }

    if (options.env) {
      for (const [name, text] of Object.entries(options.env)) {
        bindings.push({ type: 'plain_text', name, text })
      }
    }

    const metadata: WorkerMetadata = {
      main_module: 'worker.js',
      compatibility_date: options.compatibilityDate || new Date().toISOString().split('T')[0],
      compatibility_flags: options.compatibilityFlags,
      bindings,
    }

    if (options.dryRun) {
      logs.push(`[dry-run] Would upload worker '${scriptName}' to Cloudflare`)
      return { success: true, logs, type: 'workers' }
    }

    let result
    if (options.dispatchNamespace) {
      logs.push(`Deploying to dispatch namespace: ${options.dispatchNamespace}`)
      result = await api.uploadToNamespace(options.dispatchNamespace, scriptName, workerCode, metadata)
    } else {
      logs.push('Deploying worker...')
      result = await api.uploadWorker(scriptName, workerCode, metadata)
    }

    if (!result.success) {
      return { success: false, error: `Deployment failed: ${result.errors?.map(e => e.message).join(', ')}`, logs, type: 'workers' }
    }

    logs.push(`Deployment successful${result.url ? `: ${result.url}` : ''}`)

    return { success: true, url: result.url, deploymentId: result.scriptId, logs, type: 'workers' }
  } catch (error) {
    return { success: false, error: error instanceof Error ? error.message : 'Unknown error', logs, type: 'workers' }
  }
}

/**
 * Deploy using managed workers.do API
 */
async function deployWithManagedApi(options: CloudflareWorkersOptions): Promise<DeployResult> {
  const projectDir = resolve(options.projectDir)
  const logs: string[] = []
  logs.push('Using managed workers.do API for deployment')

  const managedApiUrl = options.managedApiUrl || process.env.WORKERS_API_URL || 'https://apis.do'

  try {
    let token: string
    if (options.dryRun) {
      token = 'dry-run-token'
      logs.push('Skipping authentication (dry run)')
    } else {
      logs.push('Authenticating via oauth.do...')
      const { ensureLoggedIn } = await import('oauth.do')
      const auth = await ensureLoggedIn()
      token = auth.token
      logs.push(auth.isNewLogin ? 'Logged in successfully' : 'Using existing session')
    }

    const sourceType = detectSourceType(projectDir)
    logs.push(`Detected adapter: ${sourceType.adapter || 'unknown'}`)

    const mode = options.mode || (sourceType.isStatic ? 'static' : 'opennext')
    logs.push(`Deployment mode: ${mode}`)

    logs.push('Building project...')
    const buildResult = await runCommand('npm', ['run', 'build'], projectDir, { dryRun: options.dryRun })

    if (!buildResult.success) {
      return { success: false, error: `Build failed: ${buildResult.error}`, logs, type: 'workers' }
    }
    logs.push('Build completed successfully')

    let workerCode: string
    const workerDir = join(projectDir, '.worker')
    const workerPath = join(workerDir, 'index.js')
    const openNextWorkerPath = join(projectDir, '.open-next', 'worker.js')

    if (mode === 'opennext' && existsSync(openNextWorkerPath)) {
      workerCode = readFileSync(openNextWorkerPath, 'utf-8')
    } else if (existsSync(workerPath)) {
      workerCode = readFileSync(workerPath, 'utf-8')
    } else {
      if (!options.dryRun) {
        mkdirSync(workerDir, { recursive: true })
        writeFileSync(workerPath, generateStaticWorkerScript())
      }
      workerCode = generateStaticWorkerScript()
    }

    const assetsDir = mode === 'opennext'
      ? join(projectDir, '.open-next', 'assets')
      : join(projectDir, '.next', 'static')

    const assets = existsSync(assetsDir) ? readFilesRecursively(assetsDir) : []
    logs.push(`Found ${assets.length} static asset(s)`)

    const payload = {
      name: options.projectName || 'mdxe-worker',
      code: workerCode,
      mode,
      compatibilityDate: options.compatibilityDate || new Date().toISOString().split('T')[0],
      compatibilityFlags: options.compatibilityFlags,
      env: options.env,
      kvNamespaces: options.kvNamespaces,
      d1Databases: options.d1Databases,
      r2Buckets: options.r2Buckets,
      dispatchNamespace: options.dispatchNamespace,
      tenantId: options.tenantId,
      assets: assets.map(a => ({ path: a.path, content: a.content })),
    }

    if (options.dryRun) {
      logs.push(`[dry-run] Would POST to ${managedApiUrl}/workers`)
      logs.push(`[dry-run] Worker name: ${payload.name}`)
      return { success: true, logs, type: 'workers' }
    }

    logs.push(`Deploying to ${managedApiUrl}/workers...`)

    const response = await fetch(`${managedApiUrl}/workers`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`,
      },
      body: JSON.stringify(payload),
    })

    if (!response.ok) {
      const error = await response.text()
      throw new Error(`HTTP ${response.status}: ${error}`)
    }

    const result = await response.json() as { success: boolean; url?: string; deploymentId?: string; error?: string }

    if (result.success) {
      logs.push(`Deployment successful${result.url ? `: ${result.url}` : ''}`)
      return { success: true, url: result.url, deploymentId: result.deploymentId, logs, type: 'workers' }
    } else {
      throw new Error(result.error || 'Unknown error')
    }
  } catch (error) {
    return { success: false, error: error instanceof Error ? error.message : 'Unknown error', logs, type: 'workers' }
  }
}

/**
 * Deploy to Cloudflare Workers
 *
 * @param options - Deployment options
 * @returns Deploy result
 *
 * @example
 * ```ts
 * import { deployToWorkers } from '@mdxe/cloudflare/workers'
 *
 * const result = await deployToWorkers({
 *   projectDir: './my-project',
 *   projectName: 'my-worker',
 * })
 *
 * console.log(result.url)
 * ```
 */
export async function deployToWorkers(options: CloudflareWorkersOptions): Promise<DeployResult> {
  const projectDir = resolve(options.projectDir)
  const logs: string[] = []

  const sourceType = detectSourceType(projectDir)
  logs.push(`Detected adapter: ${sourceType.adapter || 'unknown'}`)
  logs.push(`Static source: ${sourceType.isStatic}`)

  const mode = options.mode || (sourceType.isStatic ? 'static' : 'opennext')
  logs.push(`Deployment mode: ${mode}`)

  // Use managed API by default (oauth.do auth)
  if (options.useManagedApi !== false && !options.useApi) {
    const result = await deployWithManagedApi({ ...options, mode })
    return { ...result, logs: [...logs, ...(result.logs || [])] }
  }

  // Use direct Cloudflare API if requested
  if (options.useApi) {
    logs.push('Using direct Cloudflare API')
    const result = await deployStaticWithApi({ ...options, mode })
    return { ...result, logs: [...logs, ...(result.logs || [])] }
  }

  // Use wrangler CLI
  if (!checkWrangler()) {
    return { success: false, error: 'wrangler is not installed. Install it with: npm install -D wrangler', logs, type: 'workers' }
  }
  logs.push('wrangler found')

  if (mode === 'static') {
    const result = await deployStaticWithWrangler({ ...options, mode })
    return { ...result, logs: [...logs, ...(result.logs || [])] }
  } else {
    const result = await deployOpenNextWithWrangler({ ...options, mode })
    return { ...result, logs: [...logs, ...(result.logs || [])] }
  }
}
